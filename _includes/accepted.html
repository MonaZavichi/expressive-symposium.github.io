<div class="col-12 col-sm-12 col-lg-12">

  <p><a href="http://conferences.computer.org/vissoft/2014/">Open Access Proceedings</a> available.</p>

  <a name="accepted"></a><h2>Accepted Papers</h2>

      <a name="chronotwigger"></a>
      Accepted papers with abstracts:

      <h4>ChronoTwigger: A Visual Analytics Tool for Understanding Source and Test Co-Evolution</h4>

      <p><a href="http://hci.cs.umanitoba.ca/">Barrett Ens</a>, Daniel Rea, Roiy Shpaner, Hadi Hemmati, <a href="http://jimyoung.ca/">James Young</a> and Pourang Irani.</p>
      <p>Applying visual analytics to large software systems can help users comprehend the wealth of information that source repository mining can produce. One concept of interest is the co-evolution of test code with source code, or how source and test files develop together over time. For example, understanding how the testing pace compares to the development pace can help test managers gauge the effectiveness of their testing strategy. A useful concept that has yet to be effectively incorporated into a co-evolution visualization is co-change. Co-change is a quantity that can identify correlations between software artifacts, and we propose using this to organize our visualization in order to enrich the analysis of co-evolution. In this paper, we implement and test an interactive visual analytics tool that displays source and test file changes over time (co-evolution) while grouping files that change together (co-change). Our new technique improves the viewer’s ability to infer information about the software development process and its relationship to testing. We discuss the development of our system and the results of a small user study with three participants. Our findings show that our visualization can lead to inferences that are not easily made using other techniques alone. (<a href="http://hci.cs.umanitoba.ca/assets/publication_files/ChronoTwigger_Final_Version.pdf">goto paper preprint</a> or <a href="http://youtu.be/PbJKZARXjmo">watch video</a>)</p>

      <a name="how-developers-visualize-compiler-messages"></a>
      <hr class="bs-docs-separator">
      <h4>How Developers Visualize Compiler Messages: A Foundational Approach to Notification Construction</h4>

      <p><a href="http://www.barik.net/">Titus Barik</a>, Kevin Lubick, Samuel Christie and <a href="http://people.engr.ncsu.edu/ermurph3/">Emerson Murphy-Hill</a>.</p>
      <p>Self-explanation is a cognitive strategy through which developers comprehend error notifications. Self-explanation, when left solely to developers, can result in a significant loss of productivity because humans are imperfect and bounded in their cognitive abilities. We argue that modern IDEs offer limited visual affordances for aiding developers with self-explanation, because compilers perform sophisticated reasoning about the causes of error messages, but do not reveal this reasoning process to the developer.</p>
      <p>The contribution of our paper is a foundational set of visual annotations that aid developers in better comprehending error messages when compilers expose their internal reasoning. We demonstrate through a user study of 28 undergraduate Software Engineering students that our annotations align with the way in which developers self-explain error notifications. We show that these annotations allow developers to give significantly better self-explanations when compared against today's dominant visualization paradigm, and that better self-explanations yield better mental models of notifications (<a href="http://people.engr.ncsu.edu/ermurph3/papers/vissoft14.pdf">goto paper preprint</a>).</p>

      <a name="information-visualization-for-software-development-teams"></a>
      <hr class="bs-docs-separator">
      <h4>Information Visualization for Agile Software Development Teams</h4>

      <p>Julia Paredes, Craig Anslow and Frank Maurer.</p>
      <p>Understanding information about software artifacts is key to successful Agile software development projects; however, sharing information about artifacts is difficult to achieve amongst team members. There are many information visualization tech- niques used to help address the difficulties of knowledge sharing, but it is not clear what is the most effective technique. This paper explores the use of information visualization techniques by Agile software development teams and presents the results of a systematic mapping study of existing literature. The results of the systematic mapping show that teams use visualization techniques for designing, developing, communicating, and tracking progress. Our findings show that visualization techniques help Agile teams increase knowledge sharing and raise awareness about software artifacts amongst team members (<a href="docs/JuliaParedes_Paper8_VISSOFT.pdf">goto paper preprint</a>).</p>

      <a name="animatrix"></a>
      <hr class="bs-docs-separator">
      <h4>AniMatrix: A Matrix-Based Visualization of Software Evolution</h4>

      <p>Sébastien Rufiange and Guy Melançon.</p>
      <p>Software designs are ever changing to adapt to new environments and requirements. Tracking and understanding changes in modules and relationships in a software network is difficult, but even more so when the software goes through several types of changes over (potentially) large change histories. The typical complexity and size of software also makes it harder to grasp software evolution patterns. In this paper, we present an interactive matrix-based visualization technique that, combined with animation, can depict how software designs evolve over time (by showing, e.g., which new modules or couplings were added or removed). Our generic approach supports dynamic weighted digraphs and is applied in the context of software evolution to analyze changes in modules and couplings. Such elements are important to determine the structural organization of software and identifying potential issues concerning the quality of a design. To demonstrate our approach, we analyzed open-source projects and discuss some of our findings regarding these evolving software designs (<a href="http://ref.rufiange.com/animatrix2014-paper">goto paper preprint</a> or <a href="http://ref.rufiange.com/animatrix2014">visit website</a>).</p>

      <a name="visualizing-the-evolution-of-systems-and-their-library-dependencies"></a>
      <hr class="bs-docs-separator">
      <h4>Visualizing the Evolution of Systems and their Library Dependencies</h4>

      <p>Raula Gaikovina Kula, <a href="http://soft.vub.ac.be/~cderoove/">Coen De Roover</a>, <a href="http://turingmachine.org/">Daniel German</a>, Takashi Ishio and <a href="http://sel.ist.osaka-u.ac.jp/people/inoue">Katsuro Inoue</a>.</p>
      <p>System maintainers face several challenges stemming from a system and its library dependencies evolving separately. Novice maintainers may lack the historical knowledge required to efficiently manage an inherited system. While some libraries are regularly updated, some systems keep a dependency on older versions. On the other hand, maintainers may be unaware that other systems have settled on a different version of a library.</p>
      <p>In this paper, we visualize how the dependency relation between a system and its dependencies evolves from two perspectives. Our system-centric dependency plots (SDP) visualize the successive library versions a system depends on over time. The radial layout and heat-map metaphor provides visual clues about the change in dependencies along the system's release history. From this perspective, maintainers can navigate to a library-centric dependants diffusion plot (LDP). The LDP is a time-series visualization that shows the diffusion of users across the different versions of a library. We demonstrate on real-world systems how our visualizations can benefit maintainers through four case scenarios (<a href="http://soft.vub.ac.be/Publications/2014/vub-soft-tr-14-11.pdf">goto paper preprint</a>).</p>

      <a name="visualizing-developer-interactions"></a>
      <hr class="bs-docs-separator">
      <h4>Visualizing Developer Interactions</h4>

      <p><a href="http://www.inf.usi.ch/phd/minelli/">Roberto Minelli</a>, Andrea Mocci, <a href="http://www.inf.unisi.ch/faculty/lanza/">Michele Lanza</a> and Lorenzo Baracchi.</p>
      <p>Integrated Development Environments (IDEs) have become the de facto standard vehicle to develop software systems. The user interface (UI) of an IDE offers a staggering amount of facilities to manipulate source code, such as inspectors, debuggers, recommenders, alternative viewers, etc. It is unclear how developers use the UI of an IDE and whether such UIs actually give appropriate support to the developers. We present a visual approach to understand and characterize development sessions from the UI perspective. The tool supporting our approach mines and processes the finest-grained UI-level events making up development sessions and presents them visually. We have collected, visualized, and analyzed hundreds of development sessions and report on our findings (<a href="http://www.inf.usi.ch/phd/minelli/downloads/Mine2014a/Mine2014a.pdf">goto paper preprint</a>).</p>

      <a name="feature-relations-graphs"></a>
      <hr class="bs-docs-separator">
      <h4>Feature Relations Graphs: A Visualisation Paradigm for Feature Constraints in Software Product Lines</h4>

      <p>Jabier Martinez, Tewfik Ziadi, <a href="http://sites.google.com/site/raulmazo/">Raul Mazo</a>, <a href="http://www.fasolabs.org/perso/bissyand/">Tegawendé F. Bissyandé</a>, <a href="http://sites.google.com/site/jacqueskleinwebpage/">Jacques Klein</a> and Yves Le Traon.</p>
      <p>Software Product Line Engineering is a mature approach enabling the derivation of product variants by assembling reusable assets. In this context, domain experts widely use Feature Models as the most accepted formalism for capturing commonality and variability in terms of features. Feature Models also describe the constraints in feature combinations. In industrial settings, domain experts often deal with Software Product Lines with high numbers of features and constraints. Furthermore, the set of features are often regrouped in different subsets that are overseen by different stakeholders in the process. Consequently, the management of the complexity of large Feature Models becomes challenging. In this paper we propose a dedicated interactive visualisation paradigm to help domain experts and stakeholders to manage the challenges in maintaining the constraints among features. We build Feature Relations Graphs (FRoGs) by mining existing product configurations. For each feature, we are able to display a FRoG which shows the impact, in terms of constraints, of the considered feature on all the other features. The objective is to help domain experts to 1) obtain a better understanding of feature constraints, 2) potentially refine the existing feature model by uncovering and formalizing missing constraints and 3) serve as a recommendation system, during the configuration of a new product, based on the tendencies found in existing configurations. The paper illustrates the visualisation paradigm with the industrial case study of the Renault's Electric Parking System Software Product Line (<a href="http://pagesperso-systeme.lip6.fr/Tewfik.Ziadi/frogs.html">watch video</a>).</p>

      <a name="combining-tiled-and-textual-views-of-code"></a>
      <hr class="bs-docs-separator">
      <h4>Combining Tiled and Textual Views of Code</h4>

      <p>Michael Homer and <a href="http://www.mcs.vuw.ac.nz/people/James-Noble">James Noble</a>.</p>
      <p>"Jigsaw puzzle" programming environments manipulate programs primarily by drag-and-drop. Generally these environments are based on their own special-purpose languages, meaning students must move on to another language as their programs grow. Tiled Grace is a tile-based editor for Grace, an educational programming language with a conventional textual syntax. Using Tiled Grace, programmers can move seamlessly between visualising their programs as tiles or source code, editing their programs via tiles or text, and continue on to traditional textual environments, all within the same programming language. We conducted a user experiment with Tiled Grace, and present the results of that experiment showing that users find dual views helpful.</p>
      <p>This paper expands on a tool demo presented at VISSOFT 2013. Subsequent to that paper we extended Tiled Grace and performed the user experiment (<a href="http://homepages.ecs.vuw.ac.nz/~mwh/vissoft2014.pdf">goto paper preprint</a>).</p>

      <a name="integrating-anomaly-diagnosis-techniques-into-spreadsheet-environments"></a>
      <hr class="bs-docs-separator">
      <h4>Integrating Anomaly Diagnosis Techniques into Spreadsheet Environments</h4>

      <p><a href="</a>">Daniel Kulesz</a>, Jonas Scheurich and <a href="http://www.visus.uni-stuttgart.de/en/institute/people/research-associates/fabian-beck.html">Fabian Beck</a>.</p>
      <p>Although spreadsheets are often faulty, end-users like them for their flexibility. Most existing approaches to spreadsheet diagnosis are fully automated and use static analysis techniques to find anomalies in formulas or methods to derive test cases without user interaction. The few more interactive approaches are based on values already present in spreadsheets as well. In our work, we advance the idea of testing spreadsheets with user-defined test scenarios but encourage visually aided creation of independent test cases by separating the definition of test scenarios from the specific values present in the spreadsheet---just like test code is separated from production code in professional software. We combine the testing approach with static analysis and integrate it into a common visual spreadsheet environment named SIFEI. It supports users in interactively creating, executing, and analyzing their own test scenarios with a number of visual markers. Findings from two qualitative studies indicate that the concept is suitable for casual spreadsheet users. (<a href="http://www.iste.uni-stuttgart.de/fileadmin/user_upload/iste/se/research/publications/download/dk_paper_vissoft2014_preprint.pdf">goto paper preprint</a> or <a href="http://www.iste.uni-stuttgart.de/en/se/forschung/publikationen/supplementary-material-vissoft-2014.html">visit website</a>)</p>

      <a name="validation-of-software-visualization-tools"></a>
      <hr class="bs-docs-separator">
      <h4>Validation of Software Visualization Tools: A Systematic Mapping Study</h4>

      <p>Abderrahmane Seriai, <a href="http://www-ens.iro.umontreal.ca/~benomaro">Omar Benomar</a>, Benjamin Cerat and <a href="http://www.iro.umontreal.ca/~sahraouh/">Houari Sahraoui</a>.</p>
      <p>Software visualization as a research field focuses on the visualization of the structure, behavior, and evolution of software. It studies techniques and methods for graphically representing these different aspects of software. Interest in software visualization has grown in recent years, producing rapid advances in the diversity of research and in the scope of proposed techniques, and aiding the application experts who use these techniques to advance their own research. Despite the importance of evaluating software visualization research, there is little work studying validation methods. As a consequence, it is usually difficult producing compelling evidence about the effectiveness of software visualization contributions. The goal of this paper is to study the validation techniques performed in the software visualization literature. We conducted a systematic mapping study of validation methods in software visualization. We consider 752 articles from multiple sources, published between 2000 and 2012, and study the validation techniques of the software visualization articles. The main outcome of this study is the lack in rigor when validating software visualization tool and techniques. Although software visualization has grown in interest in the last decade, it still lacks the necessary maturity to be properly and thoroughly evaluating its claims. Most article evaluations studied in this paper are qualitative case studies, including discussions about the benefits of the proposed visualizations. The results help understand the needs in software visualization validation techniques. They identify the type of evaluations that should be performed to address this deficiency. The specific analysis of SOFTVIS series articles shows that the specialized conference suffers from the same shortage.</p>

      <a name="regvis"></a>
      <hr class="bs-docs-separator">
      <h4>Lightweight Structured Visualization of Assembler Control Flow based on Regular Expressions</h4>

      <p>Sibel Toprak, Arne Wichmann and Sibylle Schupp.</p>
      <p>regVIS is a tool for viewing directed graphs with start and end nodes. It applies a new visualization technique, which uses regular expressions as a meta-representation of all the paths in an input graph; the result is a containment-based and structured visualization of that graph. The tool can be configured to derive these regular expressions from the input graph using either the Brzozowski algebraic method or the transitive closure method.</p>
      <p>regVIS can be used in combination with the binary code analysis tool IDA (Interactive Disassembler), either integrated or standalone, to view the control flow graph (CFG) of assembler code. The resulting visualization, which restructures the control flow and can thus help reduce program comprehension efforts, is called control flow blocks (CFB).</p>
      <p>In this paper, we present the workings of regVIS and evaluate the new CFB visualization it produces against the traditional CFG visualization in an explorative user study. The study suggests that the CFB is better for analyzing and navigating along specific execution paths, while the CFG is better for getting an overview of the overall control flow (<a href="http://www.sts.tu-harburg.de/projects/regvis/regvis.html">visit website</a>).</p>

      <a name="search-space-pruning-constraints-visualization"></a>
      <hr class="bs-docs-separator">
      <h4>Search Space Pruning Constraints Visualization</h4>

      <p>Blake Haugen and Jakub Kurzak.</p>
      <p>Software performance optimization and many other fields are interested in finding an optimal solution in a large search space. These search spaces are often large, complex, non- linear and even non-continuous at times. The size of the search space makes the a brute force solution intractable. As a result, one or more search space pruning constraints are often used to reduce the number of candidate configurations that must be evaluated in order to solve the optimization problem.</p>
      <p>If more than one pruning constraint is employed, it can be challenging to understand how the pruning constraints interact and overlap. This work presents a visualization technique based on a radial, space-filling technique that allows the user to gain a better understanding of how the pruning constraints remove candidates from the search space. The technique is then demonstrated using a search space pruning data set derived from the optimization of a matrix multiplication code for NVIDIA CUDA accelerators (<a href="http://vimeo.com/96285958">watch video</a>).</p>
    
      <hr class="bs-docs-separator">

      <a name="using-a-task-oriented-framework-for-the-characterization-of-visualization-approaches"></a>
      <h2>NIER</h2>

      <h4>Using a Task-Oriented Framework for the Characterization of Visualization Approaches</h4>

      <p><a href="http://www.cos.ufrj.br/~schots/">Marcelo Schots</a> and <a href="http://www.cos.ufrj.br/~werner">Claudia Werner</a>.</p>
      <p>Several visualization approaches have been proposed for supporting different stakeholders in performing a variety of tasks. These approaches are spread in the literature, and can be classified and categorized by means of a taxonomy framework and its dimensions. This paper presents the extension of a task-oriented framework for better guiding the mapping of information to the existing dimensions and capturing additional ones that may be useful in evaluating the suitability of a particular visualization. Its use in practice is demonstrated in the context of a secondary study that was conducted for characterizing visualizations that provide support for software reuse tasks. Besides enabling a better organization of the findings, the extended framework allowed for the identification of aspects that lack more support, which may represent opportunities for researchers on software reuse and software visualization (<a href="http://www.cos.ufrj.br/~schots/papers/schots2014c.pdf">goto paper preprint</a> or <a href="http://www.cos.ufrj.br/~schots/survis_reuse/">visit website</a>).</p>

      <a name="a-domain-specific-language-for-visualizing-software-dependencies-as-a-graph"></a>
      <hr class="bs-docs-separator">
      <h4>A Domain-Specific Language for Visualizing Software Dependencies as a Graph</h4>

      <p><a href="http://www.bergel.eu">Alexandre Bergel</a>, Sergio Maass, <a href="http://stephane.ducasse.free.fr">Stéphane Ducasse</a> and <a href="http://www.tudorgirba.com/">Tudor Girba</a>.</p>
      <p>Graph are commonly used to visually represent software dependencies. However, adequately visualizing software dependencies as a graph is a non-trivial problem due to the pluridimentional nature of software. We have designed a domain-specific language for visualizing software dependencies as graphs that is both expressive and concise. GRAPH, the implementation of our DSL, features a seamless mapping between visual dimensions to software metrics, composition of graph layouts, graph partition, and hierarchical bundle edges (<a href="https://vimeo.com/94724841">watch video1</a> or <a href="https://vimeo.com/96091089">watch video2</a>).</p>

      <a name="fave"></a>
      <hr class="bs-docs-separator">
      <h4>FAVe: Visualizing User Feedback for Software Evolution</h4>

      <p>Emitza Guzman, Padma Bhuvanagiri and Bernd Bruegge.</p>
      <p>App users can submit feedback about downloaded apps by writing review comments and giving star ratings directly in the distribution platforms. Previous research has shown that this type of feedback contains important information for software evolution. However, in the case of the most popular apps, the amount of received feedback and its unstructured nature can make its analysis challenging. In this paper we present an interactive user feedback visualization which displays app reviews from four different points of view: general, review based, feature based and topic-feature based. We use a collocation finding algorithm for extracting the app features mentioned in the reviews and topic modeling for grouping related features. Additionally, we use sentiment analysis for finding the opinions that users have about the mentioned features. We visualized the results of the mining process for 7 different projects from two app distribution platforms with a total number of review comments in the 1538- 8878 range. Our approach can help developers and analysts get an overview of the most and least popular app features, as well as aid them when making decisions of which features to improve, add, delete or modify during software evolution.</p>

      <a name="slicing-based-techniques-for-visualizing-large-metamodels"></a>
      <hr class="bs-docs-separator">
      <h4>Slicing-based Techniques for Visualizing Large Metamodels</h4>

      <p><a href="http://people.irisa.fr/Arnaud.Blouin/">Arnaud Blouin</a>, Naouel Moha, <a href="http://www.irisa.fr/triskell/perso_pro/bbaudry/">Benoit Baudry</a> and <a href="http://www.iro.umontreal.ca/~sahraouh/">Houari Sahraoui</a>.</p>
      <p>In model-driven engineering, a model describes an aspect of a system. A model conforms to a metamodel that defines the concepts and relationships of a given domain. Metamodels are thus corner-stones of various meta-modeling activities that require a good understanding of the metamodels or parts of them. Current metamodel editing tools are based on standard visualization and navigation features, such as physical zooms. However, as soon as metamodels become larger, navigating through large metamodels becomes a tedious task that hinders their understanding. In this work, we promote the use of model slicing techniques to build visualization techniques dedicated to metamodels. We propose an approach based on model slicing, inspired from program slicing, to build interactive visualization techniques dedicated to metamodels. These techniques permit users to focus on metamodel elements of interest, which aims at improving the understandability. This approach is implemented in a metamodel visualizer, called Explen (<a href="http://hal.inria.fr/docs/01/05/62/17/PDF/vissoft14Blouin.pdf">goto paper preprint</a> or <a href="https://github.com/arnobl/kompren/wiki">visit website</a>).</p>

      <a name="action-based-visualization"></a>
      <hr class="bs-docs-separator">
      <h4>Action-Based Visualization</h4>

      <p>Antti Jääskeläinen, Hannu-Matti Järvinen and Heikki Virtanen</p>
      <p>Many commonly used systems, for example event-based systems, can be considered action systems. Traditionally, action systems have only been visualized behaviorally using state diagrams, which requires translating the system into a state machine and discarding structural information. We introduce an action-based diagram and associated formalism that depict both the behavior and the structure of the system as actions, objects, and participations. The diagrams are useful for visualizing action systems in a native format and can provide an action-oriented viewpoint to other systems as well.</p>

      <a name="the-challenge-of-helping-the-programmer-during-debugging"></a>
      <hr class="bs-docs-separator">
      <h4>The Challenge of Helping the Programmer During Debugging</h4>

      <p><a href="http://www.cs.brown.edu/people/spr">Steven Reiss</a>.</p>
      <p>Programmers spend considerable time debugging their systems. They add logging statements and use debuggers to run their systems in a controlled environment all in an attempt to understand what is happening as their program executes. Our hypothesis is that visualization tools can significantly improve the debugging process. A wide variety of tools have been developed for visualizing and understanding the dynamics of program execution. These tools can provide lots of information about executions. However, almost all of these tools are standalone; they are not designed to be used in conjunction with a debugger. What is needed are tools that can work while the programmer is debugging a system and that provide the information the programmer needs to understand and assist the debugging process. We have started to develop such tools within the context of the Code Bubbles development environment. However, there is much room for improvement and we call upon the software visualization community to think about and develop practical tools that will improve the debugging process.</p>

      <a name="templated-visualization-of-object-state-with-vebugger"></a>
      <hr class="bs-docs-separator">
      <h4>Templated Visualization of Object State with Vebugger</h4>
      
      <p><a href="http://www.cs.ubc.ca/~rodaniel/">Daniel Rozenberg</a> and <a href="http://www.cs.ubc.ca/~bestchai/">Ivan Beschastnikh</a>.</p>
      <p>Software developers often need to inspect the state of objects during debugging. Existing debuggers display a textual representation of the state of selected objects. While these textual representations often contain enough information, they are also difficult to comprehend. For example, an object that represents a color is traditionally represented by listing the numbers that comprise its RGB values. This representation, while complete, is hardly comprehensible.</p>
      <p>We describe Vebugger, an IDE plugin for Eclipse that displays object state visually. Recalling the previous example, Vebugger displays the actual color that a Color object represents in addition to its RGB values. This representation is easier to understand. Vebugger visualizes object types using a set of extensible templates. These templates are written in HTML and CSS, and they are matched to Java types by inspecting the type hierarchy. We developed a dozen such templates for a diverse set of Java types to demonstrate the capabilities of the system. Vebugger is preliminary work, we also detail future research directions and our planned evaluation strategy (<a href="http://www.cs.ubc.ca/~rodaniel/papers/vissoft14_vebugger.pdf">open paper preprint</a> or <a href="https://github.com/daniboy/vebugger">visit tool website</a>).</p>

      <a name="livecoding-the-synthkit"></a>
      <hr class="bs-docs-separator">
      <h4>Livecoding the SynthKit: littleBits as an embodied programming language</h4>
      
      <p><a href="http://www.mcs.vuw.ac.nz/people/James-Noble">James Noble</a>.</p>
      <p>littleBits (littleBits.cc) is an open-source hardware library of pre-assembled analogue components that can be easily assembled into circuits, disassembled, reassembled, and re-used. In this paper, we consider littleBits as a physically-embodied domain specific programming language. We describe the littleBits system, explain how littleBits "programs" are constructed as configurations of physical modules in the real world, and describe how they are typically used to control physical artefacts or constructions. We then argue that littleBits constructions essentially 'visualise themselves'. We describe how littleBits' liveness, embodiment, and plasticity assists both learning and debugging, and then evaluate littleBits configurations according to the cognitive dimensions of notations.</p>

      <hr class="bs-docs-separator">

      <h2>Tool Demo</h2>

      <a name="polyptychon"></a>
      <h4>Polyptychon: A Hierarchically-constrained Classified Dependencies Visualization</h4>
      
      <p>Donny T. Daniel, Egon Wuchner, Konstantin Sokolov, Michael Stal and Peter Liggesmeyer.</p>
      <p>Architects and developers are often tasked with evaluating or maintaining unfamiliar software systems. Reverse engineering tools help extract relationships between the system parts as they exist instead of as documented. Though node-link diagrams have a straightforward correspondence with the graph-representable data generated, the scale and complexity of real-world data sets prevent efficient comprehension.</p>
      <p>This paper presents Polyptychon, an interactive node-link visualization designed for incremental exploration of dependency information. Given a hierarchical information space of software artifacts, Polyptychon constrains the visible dependencies to be related to the child nodes of a specified artifact node, called a view root. It then classifies these siblings as levelized, tangled and independent. It also includes context nodes, which are a filtered set of nodes elsewhere in the hierarchy that are related to the siblings. The context nodes are further grouped based on a project-specific partition function. The hierarchical constraints and partition function provide means to control the number of nodes displayed, while the dependency classification allows users to form a qualitative impression of the dependency structure. We demonstrate with examples from the Netty open source project. We conclude with areas of future work, in particular, as a basis of evolutionary dependency analysis (<a href="http://www.donny.in/papers/vissoft-2014.pdf">open paper preprint</a>).</p>

      <a name="solidsdd"></a>
      <hr class="bs-docs-separator">
      <h4>Visual Clone Analysis with SolidSDD</h4>

      <p>Lucian Voinea and <a href="http://www.cs.rug.nl/~alext">Alexandru Telea</a>.</p>
      <p>We present SolidSDD, an integrated tool for the extraction and visual analysis of code clones. The design of SolidSDD aims to simplify and speed up the entire process of extraction of clones from code bases written in C, C++, Java, and C#, and visual analysis of the extracted results. To this end, we combine several scalable visualization techniques such as hierarchical edge bundles, table lenses, annotated text views, and linked views. We demonstrate SolidSDD for both fine-grained clone analysis and aggregated report production tasks on several large-scale code bases (<a href="http://www.cs.rug.nl/~alext/PAPERS/VISSOFT14/paper.pdf">open paper preprint</a>).</p>

      <a name="mr-clean"></a>
      <hr class="bs-docs-separator">
      <h4>Mr. Clean: a Tool for Tracking and Comparing the Lineage of Scientific Visualization Code</h4>

      <p>Giacomo Tartari, Lars Tiede, Einar Jakobsen Holsbø, Kenneth Knudsen, Inge Alexander Raknes, Bjørn Fjukstad, Nicolle Mode, John Markus Bjørndalen, Eiliv Lund and Lars Ailo Bongo.</p>
      <p>Visualization is a key step in scientific analysis and understanding in many fields. Scientific studies often require development of software that produces visualizations. However, as a study proceeds, the software evolves, and both developers and expert users have to periodically ascertain how code modi- fications affect visualization output and hence the results of the study. To our knowledge, no current visualization framework enables tracking and comparison of the lineage of scientific visualizations. We describe an approach for comparing and maintaining the code for scientific analysis and modeling through interactive comparison of visualization output. We have realized this approach in a tool called Mr. Clean. This tool provides a framework for combining different visualization tools, interaction devices, and display middleware for visual comparisons on high- resolution displays. Mr. Clean also provides user-configurable interactions supported by many devices. We provide use cases and a requirement analysis for our approach, and we describe the design and implementation of Mr. Clean (<a href="http://bdps.cs.uit.no/papers/vissoft14.pdf">open paper preprint</a>).</p>

</div><!--/span-->